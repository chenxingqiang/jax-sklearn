# Authors: The scikit-learn developers
# SPDX-License-Identifier: BSD-3-Clause

"""
Algorithm Migrator for SecretFlow

Automatically migrate sklearn/jax-sklearn algorithms to SecretFlow
with minimal manual work.

Usage:
    python algorithm_migrator.py --algorithm PCA --mode ss --test
"""

import argparse
import inspect
import os
from typing import Type, List, Dict, Any
from pathlib import Path


class AlgorithmMigrator:
    """
    自动将 sklearn 算法迁移到 SecretFlow
    
    Features:
    - 自动生成适配器代码
    - 自动生成测试用例
    - 自动生成文档
    - 批量迁移支持
    """
    
    def __init__(self, output_dir: str = "xlearn/_secretflow/generated"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def migrate_algorithm(
        self,
        sklearn_class: Type,
        mode: str = "ss",  # ss, fl, sl
        custom_config: Dict[str, Any] = None
    ) -> str:
        """
        迁移单个算法
        
        Parameters
        ----------
        sklearn_class : Type
            sklearn/jax-sklearn 算法类
        mode : str
            迁移模式: 'ss' (Simple Sealed), 'fl' (Federated), 'sl' (Split)
        custom_config : dict
            自定义配置
        
        Returns
        -------
        code : str
            生成的适配器代码
        """
        algorithm_name = sklearn_class.__name__
        
        if mode == "ss":
            code = self._generate_ss_adapter(sklearn_class, custom_config)
        elif mode == "fl":
            code = self._generate_fl_adapter(sklearn_class, custom_config)
        else:
            raise ValueError(f"Unsupported mode: {mode}")
        
        # 写入文件
        output_file = self.output_dir / f"{mode}_{algorithm_name.lower()}.py"
        with open(output_file, 'w') as f:
            f.write(code)
        
        print(f"✅ Generated adapter: {output_file}")
        
        # 生成测试
        test_code = self._generate_test(sklearn_class, mode)
        test_file = self.output_dir / f"test_{mode}_{algorithm_name.lower()}.py"
        with open(test_file, 'w') as f:
            f.write(test_code)
        
        print(f"✅ Generated test: {test_file}")
        
        return code
    
    def _generate_ss_adapter(
        self,
        sklearn_class: Type,
        custom_config: Dict[str, Any] = None
    ) -> str:
        """生成 Simple Sealed 适配器代码"""
        
        algorithm_name = sklearn_class.__name__
        class_name = f"SS{algorithm_name}"
        
        # 分析类的方法
        methods = self._analyze_class_methods(sklearn_class)
        
        # 生成代码
        code = f'''# Authors: The scikit-learn developers
# SPDX-License-Identifier: BSD-3-Clause

"""
Auto-generated adapter for {algorithm_name}
Mode: Simple Sealed (SS)
Generated by AlgorithmMigrator
"""

import logging
from typing import Union

import jax.numpy as jnp

try:
    from xlearn.{self._get_module_name(sklearn_class)} import {algorithm_name}
except ImportError:
    from sklearn.{self._get_module_name(sklearn_class)} import {algorithm_name}

try:
    from secretflow.data.ndarray.ndarray import FedNdarray
    from secretflow.data.vertical.dataframe import VDataFrame
    from secretflow.device.device.spu import SPU, SPUObject
    from secretflow.device.driver import wait
    from secretflow.ml.base import _ModelBase
    SECRETFLOW_AVAILABLE = True
except ImportError:
    SECRETFLOW_AVAILABLE = False
    logging.warning("SecretFlow not available")
    
    class _ModelBase:
        def __init__(self, spu):
            self.spu = spu


class {class_name}(_ModelBase):
    """
    Simple Sealed {algorithm_name} for SecretFlow
    
    Privacy-preserving {algorithm_name} that runs in SPU environment.
    
    This is an auto-generated adapter that wraps jax-sklearn's {algorithm_name}
    for use in SecretFlow's privacy-preserving computation framework.
    
    Parameters
    ----------
    spu : SPU
        SecretFlow SPU device for secure computation
    **kwargs : dict
        Parameters passed to {algorithm_name}
    
    Examples
    --------
    >>> import secretflow as sf
    >>> from xlearn._secretflow import {class_name}
    >>> 
    >>> sf.init(['alice', 'bob', 'carol'])
    >>> spu = sf.SPU(...)
    >>> 
    >>> model = {class_name}(spu)
    >>> model.fit(fed_data)
    >>> predictions = model.predict(fed_test_data)
    """
    
    def __init__(self, spu: "SPU", **kwargs):
        super().__init__(spu)
        self.kwargs = kwargs
        logging.info(f"[XLearn-SF] {class_name} initialized")
    
    def _to_spu_dataset(self, x: Union["FedNdarray", "VDataFrame"]) -> "SPUObject":
        """Convert federated data to SPU tensor"""
        x, _ = self._prepare_dataset(x)
        return self.spu(self._concatenate, static_argnames=("axis",))(
            self._to_spu(x),
            axis=1,
        )
'''
        
        # 添加 fit 方法
        if "fit" in methods:
            code += self._generate_fit_method(sklearn_class, algorithm_name)
        
        # 添加 predict 方法
        if "predict" in methods:
            code += self._generate_predict_method(sklearn_class, algorithm_name)
        
        # 添加 transform 方法 (如果有)
        if "transform" in methods:
            code += self._generate_transform_method(sklearn_class, algorithm_name)
        
        # 添加其他常用方法
        if "fit_transform" in methods:
            code += self._generate_fit_transform_method(sklearn_class, algorithm_name)
        
        if "score" in methods:
            code += self._generate_score_method(sklearn_class, algorithm_name)
        
        return code
    
    def _generate_fit_method(self, sklearn_class: Type, algorithm_name: str) -> str:
        """生成 fit 方法"""
        
        # 获取 fit 方法签名
        fit_signature = inspect.signature(sklearn_class.fit)
        params = list(fit_signature.parameters.keys())
        
        has_y = 'y' in params
        
        code = f'''
    def fit(self, x: Union["FedNdarray", "VDataFrame"]'''
        
        if has_y:
            code += ''', y: Union["FedNdarray", "VDataFrame"] = None'''
        
        code += f''', **fit_kwargs):
        """
        Fit {algorithm_name} model in privacy-preserving manner
        
        Parameters
        ----------
        x : FedNdarray or VDataFrame
            Training data
'''
        
        if has_y:
            code += '''        y : FedNdarray or VDataFrame, optional
            Target values
'''
        
        code += '''        **fit_kwargs : dict
            Additional parameters for fit
        
        Returns
        -------
        self
        """
        if not SECRETFLOW_AVAILABLE:
            raise RuntimeError("SecretFlow not available")
        
        spu_x = self._to_spu_dataset(x)
'''
        
        if has_y:
            code += '''        spu_y = self._to_spu(y)[0] if y is not None else None
        
        logging.info(f"[XLearn-SF] Fitting model, x_shape={x.shape}")
        
        def _spu_fit(x, y=None):
            model = ''' + algorithm_name + '''(**self.kwargs)
            if y is not None:
                model.fit(x, y, **fit_kwargs)
            else:
                model.fit(x, **fit_kwargs)
            return self._extract_model_state(model)
        
        self.model_state = self.spu(_spu_fit)(spu_x, spu_y)
'''
        else:
            code += '''        
        logging.info(f"[XLearn-SF] Fitting model, x_shape={x.shape}")
        
        def _spu_fit(x):
            model = ''' + algorithm_name + '''(**self.kwargs)
            model.fit(x, **fit_kwargs)
            return self._extract_model_state(model)
        
        self.model_state = self.spu(_spu_fit)(spu_x)
'''
        
        code += '''        wait([self.model_state])
        logging.info("[XLearn-SF] Model fitting completed")
        return self
'''
        
        return code
    
    def _generate_predict_method(self, sklearn_class: Type, algorithm_name: str) -> str:
        """生成 predict 方法"""
        
        return f'''
    def predict(self, x: Union["FedNdarray", "VDataFrame"]) -> "SPUObject":
        """Predict using the fitted model"""
        assert hasattr(self, "model_state"), "Model not fitted. Call fit() first."
        
        spu_x = self._to_spu_dataset(x)
        
        def _spu_predict(x, model_state):
            model = {algorithm_name}(**self.kwargs)
            self._restore_model_state(model, model_state)
            return model.predict(x)
        
        return self.spu(_spu_predict)(spu_x, self.model_state)
'''
    
    def _generate_transform_method(self, sklearn_class: Type, algorithm_name: str) -> str:
        """生成 transform 方法"""
        
        return f'''
    def transform(self, x: Union["FedNdarray", "VDataFrame"]) -> "SPUObject":
        """Transform data using the fitted model"""
        assert hasattr(self, "model_state"), "Model not fitted. Call fit() first."
        
        spu_x = self._to_spu_dataset(x)
        
        def _spu_transform(x, model_state):
            model = {algorithm_name}(**self.kwargs)
            self._restore_model_state(model, model_state)
            return model.transform(x)
        
        return self.spu(_spu_transform)(spu_x, self.model_state)
'''
    
    def _generate_fit_transform_method(self, sklearn_class: Type, algorithm_name: str) -> str:
        """生成 fit_transform 方法"""
        
        return '''
    def fit_transform(self, x: Union["FedNdarray", "VDataFrame"], y=None) -> "SPUObject":
        """Fit and transform in one step"""
        self.fit(x, y)
        return self.transform(x)
'''
    
    def _generate_score_method(self, sklearn_class: Type, algorithm_name: str) -> str:
        """生成 score 方法"""
        
        return f'''
    def score(
        self, 
        x: Union["FedNdarray", "VDataFrame"],
        y: Union["FedNdarray", "VDataFrame"]
    ) -> "SPUObject":
        """Calculate model score"""
        assert hasattr(self, "model_state"), "Model not fitted. Call fit() first."
        
        spu_x = self._to_spu_dataset(x)
        spu_y = self._to_spu(y)[0]
        
        def _spu_score(x, y, model_state):
            model = {algorithm_name}(**self.kwargs)
            self._restore_model_state(model, model_state)
            return model.score(x, y)
        
        return self.spu(_spu_score)(spu_x, spu_y, self.model_state)
'''
    
    def _generate_test(self, sklearn_class: Type, mode: str) -> str:
        """生成测试代码"""
        
        algorithm_name = sklearn_class.__name__
        class_name = f"SS{algorithm_name}" if mode == "ss" else f"FL{algorithm_name}"
        
        return f'''# Authors: The scikit-learn developers
# SPDX-License-Identifier: BSD-3-Clause

"""
Auto-generated tests for {class_name}
"""

import pytest
import numpy as np

try:
    import secretflow as sf
    from secretflow.data import FedNdarray, PartitionWay
    from secretflow.device.driver import reveal
    SECRETFLOW_AVAILABLE = True
except ImportError:
    SECRETFLOW_AVAILABLE = False

from xlearn._secretflow.generated.{mode}_{algorithm_name.lower()} import {class_name}


@pytest.mark.skipif(not SECRETFLOW_AVAILABLE, reason="SecretFlow not available")
def test_{algorithm_name.lower()}_basic():
    """Basic functionality test"""
    # Initialize SecretFlow
    sf.init(['alice', 'bob'], address='local')
    spu = sf.SPU(sf.utils.testing.cluster_def(['alice', 'bob']))
    
    alice = sf.PYU('alice')
    bob = sf.PYU('bob')
    
    # Create test data
    X = np.random.randn(100, 10)
    X_alice = X[:, :5]
    X_bob = X[:, 5:]
    
    # Create federated data
    fed_X = FedNdarray(
        partitions={{
            alice: alice(lambda x: x)(X_alice),
            bob: bob(lambda x: x)(X_bob),
        }},
        partition_way=PartitionWay.VERTICAL
    )
    
    # Test model
    model = {class_name}(spu)
    model.fit(fed_X)
    
    # Basic assertions
    assert hasattr(model, 'model_state')
    
    sf.shutdown()


@pytest.mark.skipif(not SECRETFLOW_AVAILABLE, reason="SecretFlow not available")
def test_{algorithm_name.lower()}_consistency():
    """Test consistency with sklearn"""
    sf.init(['alice', 'bob'], address='local')
    spu = sf.SPU(sf.utils.testing.cluster_def(['alice', 'bob']))
    
    alice = sf.PYU('alice')
    bob = sf.PYU('bob')
    
    # Create test data
    np.random.seed(42)
    X = np.random.randn(50, 10)
    
    # Test with sklearn
    from sklearn.{self._get_module_name(sklearn_class)} import {algorithm_name}
    sklearn_model = {algorithm_name}()
    sklearn_model.fit(X)
    sklearn_pred = sklearn_model.predict(X)
    
    # Test with SecretFlow adapter
    X_alice = X[:, :5]
    X_bob = X[:, 5:]
    
    fed_X = FedNdarray(
        partitions={{
            alice: alice(lambda x: x)(X_alice),
            bob: bob(lambda x: x)(X_bob),
        }},
        partition_way=PartitionWay.VERTICAL
    )
    
    sf_model = {class_name}(spu)
    sf_model.fit(fed_X)
    sf_pred = reveal(sf_model.predict(fed_X))
    
    # Compare results (allowing small numerical differences)
    np.testing.assert_allclose(sklearn_pred, sf_pred, rtol=1e-3, atol=1e-5)
    
    sf.shutdown()


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
'''
    
    def _analyze_class_methods(self, sklearn_class: Type) -> List[str]:
        """分析类的方法"""
        methods = []
        for name, method in inspect.getmembers(sklearn_class, predicate=inspect.isfunction):
            if not name.startswith('_'):
                methods.append(name)
        return methods
    
    def _get_module_name(self, sklearn_class: Type) -> str:
        """获取模块名"""
        module = sklearn_class.__module__
        if 'xlearn' in module:
            parts = module.split('.')
            return parts[1] if len(parts) > 1 else 'unknown'
        elif 'sklearn' in module:
            parts = module.split('.')
            return parts[1] if len(parts) > 1 else 'unknown'
        return 'unknown'
    
    def batch_migrate(
        self,
        algorithms: List[tuple],  # [(class, mode), ...]
        parallel: bool = False
    ):
        """批量迁移算法"""
        for sklearn_class, mode in algorithms:
            try:
                print(f"\n迁移 {sklearn_class.__name__} (mode={mode})...")
                self.migrate_algorithm(sklearn_class, mode)
            except Exception as e:
                print(f"❌ 迁移失败: {e}")
                continue


def main():
    """命令行入口"""
    parser = argparse.ArgumentParser(description="Migrate sklearn algorithms to SecretFlow")
    parser.add_argument("--algorithm", type=str, help="Algorithm name to migrate")
    parser.add_argument("--mode", type=str, default="ss", choices=["ss", "fl", "sl"],
                       help="Migration mode")
    parser.add_argument("--batch", action="store_true", help="Batch migration mode")
    parser.add_argument("--output", type=str, default="xlearn/_secretflow/generated",
                       help="Output directory")
    
    args = parser.parse_args()
    
    migrator = AlgorithmMigrator(output_dir=args.output)
    
    if args.batch:
        # 批量迁移常用算法
        from xlearn.decomposition import PCA, TruncatedSVD, NMF
        from xlearn.linear_model import Ridge, Lasso, ElasticNet
        from xlearn.cluster import MiniBatchKMeans, DBSCAN
        
        algorithms = [
            (PCA, "ss"),
            (TruncatedSVD, "ss"),
            (NMF, "ss"),
            (Ridge, "ss"),
            (Lasso, "ss"),
            (ElasticNet, "ss"),
            (MiniBatchKMeans, "ss"),
            (DBSCAN, "ss"),
        ]
        
        print("开始批量迁移...")
        migrator.batch_migrate(algorithms)
        print("\n✅ 批量迁移完成!")
        
    elif args.algorithm:
        # 单个算法迁移
        # 动态导入算法
        module_name, class_name = args.algorithm.rsplit('.', 1)
        module = __import__(module_name, fromlist=[class_name])
        sklearn_class = getattr(module, class_name)
        
        migrator.migrate_algorithm(sklearn_class, args.mode)
        print(f"\n✅ 迁移完成: {class_name}")
    
    else:
        parser.print_help()


if __name__ == "__main__":
    main()

