# Authors: The scikit-learn developers
# SPDX-License-Identifier: BSD-3-Clause

"""
SecretFlow adapter for MultiOutputClassifier

Auto-generated adapter that provides privacy-preserving MultiOutputClassifier
using SecretFlow's SPU (Secure Processing Unit).

Mode: Simple Sealed (SS)
Generated by: StandaloneAlgorithmMigrator
"""

import logging
from typing import Union, Optional

import jax.numpy as jnp
import numpy as np

# Try to import from xlearn first, fallback to sklearn
try:
    from xlearn.multioutput import MultiOutputClassifier
    USING_XLEARN = True
except ImportError:
    from sklearn.multioutput import MultiOutputClassifier
    USING_XLEARN = False

# SecretFlow imports
try:
    from secretflow.data.ndarray.ndarray import FedNdarray
    from secretflow.data.vertical.dataframe import VDataFrame
    from secretflow.device.device.spu import SPU, SPUObject
    from secretflow.device.driver import wait, reveal
    from secretflow.ml.base import _ModelBase
    SECRETFLOW_AVAILABLE = True
except ImportError:
    SECRETFLOW_AVAILABLE = False
    logging.warning("SecretFlow not available")
    
    class _ModelBase:
        """Mock base class for development without SecretFlow"""
        def __init__(self, spu):
            self.spu = spu
        
        def _prepare_dataset(self, ds):
            raise NotImplementedError("SecretFlow not installed")
        
        def _to_spu(self, d):
            raise NotImplementedError("SecretFlow not installed")
        
        @staticmethod
        def _concatenate(*args, **kwargs):
            raise NotImplementedError("SecretFlow not installed")


class SSMultiOutputClassifier(_ModelBase):
    """
    Privacy-Preserving MultiOutputClassifier using SecretFlow SPU
    
    This adapter wraps sklearn's MultiOutputClassifier (or jax-sklearn if available)
    to work in SecretFlow's privacy-preserving computation framework.
    
    All computation happens in SPU's secure environment using MPC protocols,
    ensuring no intermediate data leakage while maintaining full functionality.
    
    Parameters
    ----------
    spu : SPU
        SecretFlow SPU device for secure computation
    **kwargs : dict
        Parameters passed to MultiOutputClassifier
        See sklearn.multioutput.MultiOutputClassifier for available parameters
    
    Attributes
    ----------
    model_state_ : SPUObject
        Trained model state stored in SPU
    
    Examples
    --------
    >>> import secretflow as sf
    >>> from xlearn._secretflow.generated.ss_multioutputclassifier import SSMultiOutputClassifier
    >>> 
    >>> # Initialize SecretFlow
    >>> sf.init(['alice', 'bob', 'carol'])
    >>> spu = sf.SPU(sf.utils.testing.cluster_def(['alice', 'bob', 'carol']))
    >>> 
    >>> # Create vertical partitioned data
    >>> fed_data = create_vertical_data(...)
    >>> 
    >>> # Train privacy-preserving model
    >>> model = SSMultiOutputClassifier(spu, **params)
    >>> model.fit(fed_data)
    >>> 
    >>> # Make predictions
    >>> predictions = model.predict(fed_test_data)
    >>> 
    >>> # Reveal results (only when necessary)
    >>> results = reveal(predictions)
    
    Notes
    -----
    - Using {'xlearn' if USING_XLEARN else 'sklearn'} implementation
    - All computation in SPU encrypted space
    - Supports vertical federated learning
    - Maintains sklearn API compatibility
    """
    
    def __init__(self, spu: "SPU", **kwargs):
        super().__init__(spu)
        self.kwargs = kwargs
        self.model_state_ = None
        
        if USING_XLEARN:
            logging.info(f"[XLearn-SF] SSMultiOutputClassifier initialized with JAX acceleration")
        else:
            logging.info(f"[XLearn-SF] SSMultiOutputClassifier initialized with sklearn implementation")
    
    def _to_spu_dataset(self, x: Union["FedNdarray", "VDataFrame"]) -> "SPUObject":
        """
        Convert federated data to SPU tensor
        
        Aggregates vertically partitioned data from multiple parties
        into a single encrypted tensor in SPU.
        """
        if not SECRETFLOW_AVAILABLE:
            raise RuntimeError("SecretFlow not installed")
        
        x, _ = self._prepare_dataset(x)
        return self.spu(self._concatenate, static_argnames=("axis",))(
            self._to_spu(x),
            axis=1,
        )
    
    def _extract_model_state(self, model) -> dict:
        """
        Extract model state for SPU storage
        
        Extracts all fitted attributes from the sklearn model
        for storage in SPU encrypted space.
        """
        state = {"kwargs": self.kwargs}
        
        # Extract all fitted attributes (ending with _)
        for attr in dir(model):
            if attr.endswith('_') and not attr.startswith('_'):
                try:
                    value = getattr(model, attr)
                    # Convert to JAX array for SPU compatibility
                    if isinstance(value, np.ndarray):
                        value = jnp.array(value)
                    state[attr] = value
                except:
                    pass
        
        return state
    
    def _restore_model_state(self, model, state: dict):
        """
        Restore model state from SPU storage
        
        Restores all fitted attributes to create a functional model.
        """
        for attr, value in state.items():
            if attr != 'kwargs':
                setattr(model, attr, value)

    def fit(
        self,
        x: Union["FedNdarray", "VDataFrame"],
        **fit_kwargs
    ) -> "SSMultiOutputClassifier":
        """
        Fit model in privacy-preserving manner
        
        All computation happens in SPU's encrypted space using MPC protocols.
        
        Parameters
        ----------
        x : FedNdarray or VDataFrame
            Vertically partitioned training data
        **fit_kwargs : dict
            Additional fit parameters
        
        Returns
        -------
        self : SSMultiOutputClassifier
            Fitted estimator
        """
        if not SECRETFLOW_AVAILABLE:
            raise RuntimeError("SecretFlow not installed")
        
        # Convert to SPU dataset
        spu_x = self._to_spu_dataset(x)
        
        logging.info(f"[XLearn-SF] Fitting {algorithm_name}, x_shape={x.shape}")
        
        def _spu_fit(x):
            """Fit function that runs in SPU environment"""
            model = MultiOutputClassifier(**self.kwargs)
            model.fit(x, **fit_kwargs)
            return self._extract_model_state(model)
        
        # Execute in SPU
        self.model_state_ = self.spu(_spu_fit)(spu_x)
        
        # Wait for computation to complete
        wait([self.model_state_])
        
        logging.info(f"[XLearn-SF] {algorithm_name} fitting completed")
        
        return self

    def predict(self, x: Union["FedNdarray", "VDataFrame"]) -> "SPUObject":
        """
        Predict using the fitted model
        
        Predictions are computed in SPU's encrypted space.
        
        Parameters
        ----------
        x : FedNdarray or VDataFrame
            Data to predict on
        
        Returns
        -------
        predictions : SPUObject
            Encrypted predictions (use reveal() to decrypt)
        """
        if self.model_state_ is None:
            raise RuntimeError("Model not fitted. Call fit() first.")
        
        spu_x = self._to_spu_dataset(x)
        
        def _spu_predict(x, model_state):
            """Predict function that runs in SPU environment"""
            model = MultiOutputClassifier(**model_state["kwargs"])
            self._restore_model_state(model, model_state)
            return model.predict(x)
        
        return self.spu(_spu_predict)(spu_x, self.model_state_)

    def score(
        self,
        x: Union["FedNdarray", "VDataFrame"],
        y: Union["FedNdarray", "VDataFrame"]
    ) -> "SPUObject":
        """
        Calculate model score
        
        Score is computed in SPU's encrypted space.
        
        Parameters
        ----------
        x : FedNdarray or VDataFrame
            Test data
        y : FedNdarray or VDataFrame
            True labels
        
        Returns
        -------
        score : SPUObject
            Model score (use reveal() to decrypt)
        """
        if self.model_state_ is None:
            raise RuntimeError("Model not fitted. Call fit() first.")
        
        spu_x = self._to_spu_dataset(x)
        spu_y = self._to_spu(y if isinstance(y, FedNdarray) else y.values)[0]
        
        def _spu_score(x, y, model_state):
            """Score function that runs in SPU environment"""
            model = MultiOutputClassifier(**model_state["kwargs"])
            self._restore_model_state(model, model_state)
            return model.score(x, y)
        
        return self.spu(_spu_score)(spu_x, spu_y, self.model_state_)
