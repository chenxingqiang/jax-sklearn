# Authors: The scikit-learn developers
# SPDX-License-Identifier: BSD-3-Clause

"""
SecretFlow adapter for chi2

Auto-generated adapter that provides privacy-preserving chi2
using SecretFlow's SPU (Secure Processing Unit).

Mode: Simple Sealed (SS)
Generated by: StandaloneAlgorithmMigrator
"""

import logging
from typing import Union, Optional

import jax.numpy as jnp
import numpy as np

# Try to import from xlearn first, fallback to sklearn
try:
    from xlearn.feature_selection import chi2
    USING_XLEARN = True
except ImportError:
    from sklearn.feature_selection import chi2
    USING_XLEARN = False

# SecretFlow imports
try:
    from secretflow.data.ndarray.ndarray import FedNdarray
    from secretflow.data.vertical.dataframe import VDataFrame
    from secretflow.device.device.spu import SPU, SPUObject
    from secretflow.device.driver import wait, reveal
    from secretflow.ml.base import _ModelBase
    SECRETFLOW_AVAILABLE = True
except ImportError:
    SECRETFLOW_AVAILABLE = False
    logging.warning("SecretFlow not available")
    
    class _ModelBase:
        """Mock base class for development without SecretFlow"""
        def __init__(self, spu):
            self.spu = spu
        
        def _prepare_dataset(self, ds):
            raise NotImplementedError("SecretFlow not installed")
        
        def _to_spu(self, d):
            raise NotImplementedError("SecretFlow not installed")
        
        @staticmethod
        def _concatenate(*args, **kwargs):
            raise NotImplementedError("SecretFlow not installed")


class SSchi2(_ModelBase):
    """
    Privacy-Preserving chi2 using SecretFlow SPU
    
    This adapter wraps sklearn's chi2 (or jax-sklearn if available)
    to work in SecretFlow's privacy-preserving computation framework.
    
    All computation happens in SPU's secure environment using MPC protocols,
    ensuring no intermediate data leakage while maintaining full functionality.
    
    Parameters
    ----------
    spu : SPU
        SecretFlow SPU device for secure computation
    **kwargs : dict
        Parameters passed to chi2
        See sklearn.feature_selection.chi2 for available parameters
    
    Attributes
    ----------
    model_state_ : SPUObject
        Trained model state stored in SPU
    
    Examples
    --------
    >>> import secretflow as sf
    >>> from xlearn._secretflow.generated.ss_chi2 import SSchi2
    >>> 
    >>> # Initialize SecretFlow
    >>> sf.init(['alice', 'bob', 'carol'])
    >>> spu = sf.SPU(sf.utils.testing.cluster_def(['alice', 'bob', 'carol']))
    >>> 
    >>> # Create vertical partitioned data
    >>> fed_data = create_vertical_data(...)
    >>> 
    >>> # Train privacy-preserving model
    >>> model = SSchi2(spu, **params)
    >>> model.fit(fed_data)
    >>> 
    >>> # Make predictions
    >>> predictions = model.predict(fed_test_data)
    >>> 
    >>> # Reveal results (only when necessary)
    >>> results = reveal(predictions)
    
    Notes
    -----
    - Using {'xlearn' if USING_XLEARN else 'sklearn'} implementation
    - All computation in SPU encrypted space
    - Supports vertical federated learning
    - Maintains sklearn API compatibility
    """
    
    def __init__(self, spu: "SPU", **kwargs):
        super().__init__(spu)
        self.kwargs = kwargs
        self.model_state_ = None
        
        if USING_XLEARN:
            logging.info(f"[XLearn-SF] SSchi2 initialized with JAX acceleration")
        else:
            logging.info(f"[XLearn-SF] SSchi2 initialized with sklearn implementation")
    
    def _to_spu_dataset(self, x: Union["FedNdarray", "VDataFrame"]) -> "SPUObject":
        """
        Convert federated data to SPU tensor
        
        Aggregates vertically partitioned data from multiple parties
        into a single encrypted tensor in SPU.
        """
        if not SECRETFLOW_AVAILABLE:
            raise RuntimeError("SecretFlow not installed")
        
        x, _ = self._prepare_dataset(x)
        return self.spu(self._concatenate, static_argnames=("axis",))(
            self._to_spu(x),
            axis=1,
        )
    
    def _extract_model_state(self, model) -> dict:
        """
        Extract model state for SPU storage
        
        Extracts all fitted attributes from the sklearn model
        for storage in SPU encrypted space.
        """
        state = {"kwargs": self.kwargs}
        
        # Extract all fitted attributes (ending with _)
        for attr in dir(model):
            if attr.endswith('_') and not attr.startswith('_'):
                try:
                    value = getattr(model, attr)
                    # Convert to JAX array for SPU compatibility
                    if isinstance(value, np.ndarray):
                        value = jnp.array(value)
                    state[attr] = value
                except:
                    pass
        
        return state
    
    def _restore_model_state(self, model, state: dict):
        """
        Restore model state from SPU storage
        
        Restores all fitted attributes to create a functional model.
        """
        for attr, value in state.items():
            if attr != 'kwargs':
                setattr(model, attr, value)
